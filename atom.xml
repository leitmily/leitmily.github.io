<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deemo的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://letmily.gitee.io/"/>
  <updated>2018-08-20T16:33:16.996Z</updated>
  <id>https://letmily.gitee.io/</id>
  
  <author>
    <name>leitmily</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP 算法详解（CPP 实现）</title>
    <link href="https://letmily.gitee.io/2018/08/04/kmp/"/>
    <id>https://letmily.gitee.io/2018/08/04/kmp/</id>
    <published>2018-08-03T16:28:09.000Z</published>
    <updated>2018-08-20T16:33:16.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;kmp 算法是由 Knuth、Morris 和 Pratt 三人设计的一个非常高效的字符串匹配算法。该算法用于判断一个字符串是否包含于另一个字符串中。该算法复杂度是 $O(m + n)$，其中 $m$ 和 $n$ 分别是两个字符串的长度。</p><h2 id="kmp-算法思想"><a href="#kmp-算法思想" class="headerlink" title="kmp 算法思想"></a>kmp 算法思想</h2><p>&emsp;&emsp;我们能很容易想到 $O(M * N)$ 复杂度的算法，即索引从字符串 str1 的第一个字符开始，依次检查以该字符作为首字符的连续 N 个字符是否与字符串 str2 匹配，若不匹配，则索引向前移动一位，从第二个字符开始依次检查，以此类推。</p><p>&emsp;&emsp;该算法并没有考虑到现已匹配的部分字符串的结构。已匹配的部分字符串中可能包含相同的部分，若利用这些相同的部分，我们可以一次性移动多位而不只是移动一位，这样大大提高了算法的效率。</p><p>&emsp;&emsp;假设现有两个字符串 str1 和 str2，并且现已从 index1 处开始检是否匹配。当我们检测到 index2 处时，发现此时待检测的两个字符不相同（即图中 A 和 B 部分字符不匹配，index2 和 index1 之间的字符均匹配），按照传统思想我们将会从 index1 + 1 处的位置开始新一轮的检测，这样检测的效率极低。当我们仔细观察现已匹配的部分字符串时，若能找到字符串中首尾相同的部分（即图中 1、2、3和4部分的字符串相同），则可以直接将 str2 向前移动 k 个位置（如图所示），即图中 2 和 4 部分将作为新匹配字符串的头部，并接着从 str1 的 index2 位置开始检测。若不含有相同的部分，此时不管是将 str2 向前移动多少位都不会出现匹配的字符串，因此，可以从 str1 的 index2 位置开始新的一轮检测（即从 str2 的第一个字符开始匹配，可以理解为将 str2 向前移动了 str2 长度的位置）。</p><div align="center"><img src="/images/articles/KMP/1.png" height="200"></div><p>&emsp;&emsp;现有如下两个字符串：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str1 = <span class="string">"bacbbacabadababacambabacadbacabacasdsd"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str2 = <span class="string">"bacabaca"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;按照上述的匹配过程可以得到如下的匹配过程图，当匹配到 index2 处时，发现字符 d 和 字符 c 不匹配，但已匹配的部分 <code>bacaba</code> 的首位相同的部分为 <code>ba</code>，该部分为字符串 <code>bacaba</code> 的最长的相同前缀和后缀，而在下一轮的匹配过程中，将 <code>ba</code> 部分作为新的首部，并接着 index2 处开始匹配。一次类推完成整个字符串的匹配过程。</p><div align="center"><img src="/images/articles/KMP/2.png" height="200"></div><p>&emsp;&emsp;由以上匹配过程可知，每当开始新一轮的匹配时，我们需要知道当前已匹配的字符串中最长相同前缀和后缀的长度，以实现匹配过程中的快速跳转。而当前已匹配的字符串长度可能为 1 ～ length(str2)，因此，我们可以创建一个长度为 n 的数组 ( n = length(str2) )，用来保存不同长度字符串的最长相同前缀和后缀的长度。该数组为 next 数组。</p><h2 id="next-数组计算"><a href="#next-数组计算" class="headerlink" title="next 数组计算"></a>next 数组计算</h2><p>&emsp;&emsp;next 数组中第 i 个数表示字符串索引从 0 到 i 的字符串最长相同前缀和后缀的长度。<code>注意，前缀和后缀不包括字符串本身，比如 aaaa 相同的最长前缀和最长后缀是 aaa</code> 。<br>&emsp;&emsp;假设我们现在已经求得 next[0]、next[1]、…… next[ i-1 ]，分别表示长度为 1 到 i 的字符串的最长相同前缀和后缀的长度。现在要求 next[ i ]。由下图我们可以看到，如果位置 i 和位置 next[ i-1 ] 处的两个字符相同（下标从零开始），则 next[ i ]等于 next[ i-1 ] + 1。</p><div align="center"><img src="/images/articles/KMP/3.png" width="700"></div><p>&emsp;&emsp;如果两个位置的字符不相同，我们可以将长度为 next[ i-1 ] 的字符串继续分割，获得其最大公共长度 next[ next[ i-1 ] -1 ]，然后再和位置 i 的字符比较。由于长度为 next[ i-1 ] 的字符串的公共长度保存在索引为 next[ i-1 ] -1 的 next 数组中，而该字符串又包含相同的前缀和后缀，如下图所示，如果位置 next[ next[ i-1 ] -1 ]和位置 i 的字符相同，则 next [i ]就等于 next[ next[ i -1 ] -1 ] + 1。如果不相等，就可以继续分割长度为 next[ next[ i -1 ] -1 ] 的字符串，直到字符串长度为 0 为止。</p><div align="center"><img src="/images/articles/KMP/4.png" width="700"></div><p>&emsp;&emsp;根据上述计算 next 数组的过程，可以写出相应的求 next 数组的代码（CPP实现）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNext(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);               <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(len, <span class="number">0</span>);            <span class="comment">// 保存结果，next[0]=0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = next[i - <span class="number">1</span>];             <span class="comment">// k 表示需要比较的位置，初始值为 next[i - 1]</span></span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; str[i] != str[k]) <span class="comment">// 比较，若不相等则继续分割，直到相等或为0(即不含相同部分)</span></span><br><span class="line">            k = next[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str[k])             <span class="comment">// 若相等，则 next[i] = k + 1，否则为0，其中 k 为索引</span></span><br><span class="line">            k++;</span><br><span class="line">        next[i] = k;                     <span class="comment">// 更新 next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在求解 next 数组后，可以利用该数组进行字符串匹配。</p><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>&emsp;&emsp;假若当前字符串 str1 的第 i 个字符正在与字符串 str2 的第 k 个字符进行匹配（i 和 k 均从 0 开始），若相等，则进行下一轮的匹配，即进行 str1 的 第 i+1 个字符与 str2 的第 k+1 个字符匹配；若不相等，则跟 str2 的第 next[k - 1] 字符进行匹配，直到 k = 0 为止。重复以上过程直到检测完 str1 的所有字符。</p><p>&emsp;&emsp;根据上述匹配过程，完成 CPP 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = getNext(str2);           <span class="comment">// 获得 str2 的 next 数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;                                  <span class="comment">// 记录当前已匹配 str2 的索引</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;                               <span class="comment">// 保存匹配的字符串起始位置，若不存在，返回-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str1); i++)  <span class="comment">// 第 i 轮匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; str1[i] != str2[k])      <span class="comment">// str1的第i个与str2的第k个字符进行比较，若不同，则k=next[k-1]，直到k为0或相等为止</span></span><br><span class="line">            k = next[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(str1[i] == str2[k])                  <span class="comment">// 若相等，更新k</span></span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">if</span>(k == (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str2))              <span class="comment">// 若找到完全匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = i - k + <span class="number">1</span>;                    <span class="comment">// 保存匹配的字符串起始位置，此时根据需要可用容器保存多个结果</span></span><br><span class="line">            k = next[k - <span class="number">1</span>];                    <span class="comment">// 进行下一轮匹配，此处根据需要可去掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上就是 KMP 算法的整个过程，完整的代码可访问 <a href="https://github.com/leitmily/Notes/tree/master/algorithm/KMP" title="KMP 算法详解（CPP 实现）" target="_blank" rel="noopener">Github</a> 下载。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6751457.html" title="KMP算法学习(详解)" target="_blank" rel="noopener">KMP算法学习(详解)</a></li><li><a href="https://blog.csdn.net/starstar1992/article/details/54913261/" title="KMP算法最浅显理解——一看就明白" target="_blank" rel="noopener">KMP算法最浅显理解 —— 一看就明白</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;kmp 算法是由 Knuth、Morris 和 Pratt 三人设计的一个非常高效的字符串匹配算法。该算法用于判断一
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://letmily.gitee.io/tags/algorithm/"/>
    
      <category term="kmp" scheme="https://letmily.gitee.io/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>【201807更新】解决注册谷歌账号时出现的错误：此电话号码无法用于进行验证</title>
    <link href="https://letmily.gitee.io/2018/07/28/googleaccount/"/>
    <id>https://letmily.gitee.io/2018/07/28/googleaccount/</id>
    <published>2018-07-27T16:23:10.000Z</published>
    <updated>2018-08-20T16:27:43.083Z</updated>
    
    <content type="html"><![CDATA[<p>最近手贱将以前注册的谷歌账号给删除了，而在重新注册账号时由于第三方邮箱的操作不友好，在输入验证码后按了个返回，导致现在的手机号无法注册，并提示 <code>此电话号码无法用于进行验证</code> ，在网上搜索了好多方法都不行，什么挂VPN、QQ邮箱等都不行，最后想了一上午终于想出来了一个可行的方法，并测试已成功申请且绑定自己的手机号。</p><p>使用该方法注册账号，你需要</p><ul><li>支付一定的费用，需首次充值10元，但充值完后可注册100个账号</li><li>不需要使用VPN，使用网易邮箱大师即可</li></ul><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>电脑和手机端同时操作，手机上需要下载APP。</p><ol><li>首先在手机上下载 <strong>网易邮箱大师</strong>，或者部分手机自带的邮箱APP，只要不出现 <code>暂时无法注册账号</code> 的错误就行，经测试 <strong>QQ邮箱</strong> 是不行的。</li><li><p>在<a href="http://www.51ym.me/" title="易码平台" target="_blank" rel="noopener">易码平台</a>（其他短信接受平台也行，不过我没去测试）注册账号，并充值。</p><p> 该平台用于专门生成一个手机号码，并用于接收短信验证码，充值最低要10块钱，没办法，要想注册账号，掏点钱就掏吧。</p></li></ol><h2 id="开始注册"><a href="#开始注册" class="headerlink" title="开始注册"></a>开始注册</h2><p>完成准备阶段，那就开始注册吧。</p><ol><li><p>打开 <strong>网易邮箱大师</strong>，随便输入个gmail的邮箱，然后点下一步。</p><p> <img src="/images/articles/googleaccount/1.PNG" height="400" align="center/"></p></li><li><p>点击创建账号，并填写个人信息以及邮箱名等信息，并点击下一步</p><p><img src="/images/articles/googleaccount/2.PNG" height="400" align="center/"></p></li><li><p>登录易码平台，点击获取验证码，选择短信项目为 <strong>google</strong>，运营商随意，然后点击 <strong>获取手机号</strong>，会生成一个手机号码。</p><p> <img src="/images/articles/googleaccount/3.PNG" height="300" align="center/"></p></li><li><p>将易码平台给的号码输入到手机上，并点击下一步，若没有问题，则会向该手机号码发一条短信，并可以在译码平台上看到验证码如下所示，在手机上输入该验证码，并点下一步。</p><p> <img src="/images/articles/googleaccount/4.PNG" height="300" align="center/"></p><p> <code>注意</code>：若出现 <strong>无法用于注册</strong> 错误，则在易码平台上点击释放手机号，并重新获取手机号，这样多试几个（一般不超过5个），若尝试多次还不行，那说明你当前注册的邮箱账号已经不能注册了，只能换一个邮箱账号注册。</p></li><li><p>填写完验证码点下一步，会出现如下界面，需要填写辅助电话号码和辅助邮箱，虽然是可选的，<code>但是</code>，该辅助电话号码和邮箱就是跟账号绑定的手机和邮箱啊，<strong>此处填写的手机号就是以后用于验证的手机号，此处非常关键，填写你需要绑定的手机号</strong> ，填完点下一步。</p><p> <img src="/images/articles/googleaccount/5.PNG" height="400" align="center/"></p></li><li><p>接下来应该会让你验证辅助的手机号码，忘截图了，不过此时可以正常收到短信，接着一路下一步，完成注册吧。</p></li></ol><p>易码平台只有收到短信才收取1毛钱，但首充要10块，不过10块买个账号也划算，毕竟还能接着注册近100个账号。好了，今天就到这里吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近手贱将以前注册的谷歌账号给删除了，而在重新注册账号时由于第三方邮箱的操作不友好，在输入验证码后按了个返回，导致现在的手机号无法注册，并提示 &lt;code&gt;此电话号码无法用于进行验证&lt;/code&gt; ，在网上搜索了好多方法都不行，什么挂VPN、QQ邮箱等都不行，最后想了一上午
      
    
    </summary>
    
    
      <category term="google" scheme="https://letmily.gitee.io/tags/google/"/>
    
  </entry>
  
  <entry>
    <title>linux下C/C++编程导入第三方库文件的几种方法</title>
    <link href="https://letmily.gitee.io/2018/07/27/inc/"/>
    <id>https://letmily.gitee.io/2018/07/27/inc/</id>
    <published>2018-07-26T16:19:57.000Z</published>
    <updated>2018-08-20T16:21:47.907Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://blog.csdn.net/zxh2075/article/details/54629318" title="linux下添加动态链接库路径的方法" target="_blank" rel="noopener">linux下添加动态链接库路径的方法</a></li><li><a href="https://blog.csdn.net/yanshaodan/article/details/71576853" title="linux添加头文件路径" target="_blank" rel="noopener">linux添加头文件路径</a></li><li><a href="https://blog.csdn.net/newchenxf/article/details/51750239" title="pkg-config 详解" target="_blank" rel="noopener">pkg-config 详解</a></li></ul><h2 id="1-添加编译选项"><a href="#1-添加编译选项" class="headerlink" title="1. 添加编译选项"></a>1. 添加编译选项</h2><p>在编译的时候添加库路径以及头文件路径选项，如</p><ul><li>-I 头文件所在的路径</li><li>-L 库文件所在的路径（包括静态库和动态库）</li><li>-l 指定库文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.c -I./inc -L./lib</span><br></pre></td></tr></table></figure><h2 id="2-修改系统环境变量"><a href="#2-修改系统环境变量" class="headerlink" title="2. 修改系统环境变量"></a>2. 修改系统环境变量</h2><p>将头文件路径和库文件路径添加到指定的系统环境变量中去，具体如下：</p><ul><li>使用 <strong>gcc</strong> 编译时将 <code>头文件</code> 路径添加到 <strong>C_INCLUDE_PATH</strong> 系统环境变量中；  </li><li>使用 <strong>g++</strong> 编译时将 <code>头文件</code> 路径添加到 <strong>CPLUS_INCLUDE_PATH</strong> 系统环境变量中；  </li><li>将 <code>动态连接库</code> 路径添加到 <strong>LD_LIBRARY_PATH</strong> 系统环境变量中；</li><li>将 <code>静态库</code> 路径添加到 <strong>LIBRARY_PATH</strong> 系统变量中。</li></ul><p>改变系统变量主要有两种形式，一种是临时改变，另一种是永久改变。</p><p>临时改变系统变量只需要使用 <strong>export</strong> 命令，重启终端后将恢复至先前状态，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export C_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/myinclude</span><br></pre></td></tr></table></figure><p>而永久改变又可分为仅改变当前用户和改变所有用户：</p><ul><li>仅改变当前用户的系统环境时，只需将上述的 <strong>export</strong> 语句添加到 <code>~/.bashrc</code> 或者 <code>~/.bash_profile</code> 文件内容后面，重启终端即可。</li><li>要改变所有用户的环境变量时，需将上述的的 <strong>export</strong> 语句添加到 <code>/etc/profile</code> 文件内容，并需要重启计算机。</li></ul><h2 id="3-使用-pkg-config-命令"><a href="#3-使用-pkg-config-命令" class="headerlink" title="3. 使用 pkg-config 命令"></a>3. 使用 pkg-config 命令</h2><p>部分第三方库在安装完成后会自动生成一个 *.pc 的配置文件用来存放第三方库安装的路径，包括头文件路径以及库文件路径，可以使用 <strong>pkg-config</strong> 命令查看，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags --libs protobuf</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; -pthread -I/usr/local/include -L/usr/local/lib -lprotobuf -pthread</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>–cflags 返回头文件目录</li><li>–libs 返回库所在的目录以及库参数</li><li>protobuf 为第三方库名</li></ul><p>在编译包含这些库的代码时，需要执行上述命令获取返回结果，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.c `pkg-config --cflags --libs protobuf`</span><br></pre></td></tr></table></figure><p>其中，`符号为数字1键左边的那键。</p><p>对于某些三方库没有<em>.pc文件，我们也可以自己写一个配置文件。\</em>.pc文件的路径存放在 <strong>PKG_CONFIG_PATH</strong> 系统变量下，使用 <strong>echo</strong> 命令可查看其变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $PKG_CONFIG_PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; :/usr/local/lib/pkgconfig</span><br></pre></td></tr></table></figure><p>进入该路径，我们可以看到 *.pc 的配置文件，用文本编辑器打开其中一个如protobuf.pc，其内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line"></span><br><span class="line">Name: Protocol Buffers</span><br><span class="line">Description: Google's Data Interchange Format</span><br><span class="line">Version: 3.5.2</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lprotobuf -pthread</span><br><span class="line">Libs.private: -lz</span><br><span class="line">Cflags: -I$&#123;includedir&#125; -pthread</span><br><span class="line">Conflicts: protobuf-lite</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>libdir 为库所在目录</li><li>includedir 为头文件所在目录</li><li>Libs 为调用参数，其内容为库所在的目录以及库参数</li><li>cflags 为调用参数，其内容为头文件目录</li></ul><p>因此，我们可以照着上面的形式自己写一个*.pc文件放到 <strong>PKG_CONFIG_PATH</strong> 所指定的目录下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/zxh2075/article/details/54629318&quot; title=&quot;linux下添加动态链接库路径的方法&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://letmily.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>GDB 基本用法，以及多进程、多线程的调试</title>
    <link href="https://letmily.gitee.io/2018/07/20/gdb/"/>
    <id>https://letmily.gitee.io/2018/07/20/gdb/</id>
    <published>2018-07-19T16:15:36.000Z</published>
    <updated>2018-08-20T16:21:03.516Z</updated>
    
    <content type="html"><![CDATA[<p>该内容主要是把几个参考的博客内容进行整理和补充，并采用markdown语法对原博客内容重写</p><h1 id="一、GDB-调试基本知识"><a href="#一、GDB-调试基本知识" class="headerlink" title="一、GDB 调试基本知识"></a>一、GDB 调试基本知识</h1><ol><li>调试器指示的是将要执行的代码行</li><li>只有在编译时拥有调试符号(-g)的程序才能在调试时看到源码</li><li>同一行上有多个断点时，gdb仅中断在断点号最小的那个断点上</li><li>断点可以设置在同一程序的不同文件中</li><li>在任何给定时间，gdb只有一个焦点，即当前“活动”的文件</li><li>源文件改变后，断点发生移动，带式断点属性的行号不变</li></ol><h1 id="二、GDB-基本命令清单查询"><a href="#二、GDB-基本命令清单查询" class="headerlink" title="二、GDB 基本命令清单查询"></a>二、GDB 基本命令清单查询</h1><p>在 gdb 提示符处键入help，将列出命令的分类，主要的分类有： </p><ul><li>aliases：命令别名</li><li>breakpoints：断点定义</li><li>data：数据查看</li><li>files：指定并查看文件</li><li>internals：维护命令</li><li>running：程序执行</li><li>stack：调用栈查看</li><li>statu：状态查看</li><li>tracepoints：跟踪程序执行</li></ul><p>键入 help 后跟命令的分类名（如help aliases），可获得该类命令的详细清单。</p><h1 id="三、GDB-基本命令用法"><a href="#三、GDB-基本命令用法" class="headerlink" title="三、GDB 基本命令用法"></a>三、GDB 基本命令用法</h1><h2 id="1-运行和退出"><a href="#1-运行和退出" class="headerlink" title="1. 运行和退出"></a>1. 运行和退出</h2><ul><li><p><strong>run（简写r）：执行程序</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run app [argv1] [argv2] ...</span><br></pre></td></tr></table></figure><p>  run命令后可跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt;)和外壳通配符（*、？、[、]）在内。<br>  如果使用不带参数的run命令，gdb就再次使用前一条run命令的参数。</p></li><li><p><strong>set args：设定传递给程序的参数</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args [argv1] [argv2] ...</span><br></pre></td></tr></table></figure></li><li><p><strong>show args：查看其缺省参数的列表</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show follow-fork-mode     # 显示参数 follow-fork-mode 选项的值</span><br></pre></td></tr></table></figure></li><li><p><strong>kill（简写k）：异常终止在gdb 控制下运行的程序</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) kill</span><br></pre></td></tr></table></figure></li><li><p><strong>quit（简写q）：退出gdb</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-查看信息"><a href="#2-查看信息" class="headerlink" title="2. 查看信息"></a>2. 查看信息</h2><ul><li><p><strong>list（简写l）：查看源码</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list line_num</span><br></pre></td></tr></table></figure><p>  或</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l line_num</span><br></pre></td></tr></table></figure><p>  其中line_num 为行号。</p><p>  查看指定文件源码：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list file_name:line_num</span><br></pre></td></tr></table></figure></li><li><p><strong>pirnt(简写p)：</strong></p><p>  print var：查看变量var的值。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print var</span><br></pre></td></tr></table></figure><p>  可以通过添加参数来设置输出格式：</p><blockquote><p>/x 按十六进制格式显示变量<br>/d 按十进制格式显示变量<br>/u 按十六进制格式显示无符号整型<br>/o 按八进制格式显示变量<br>/t 按二进制格式显示变量<br>/a 按十六进制格式显示变量<br>/c 按字符格式显示变量<br>/f 按浮点数格式显示变量</p></blockquote><p>  例如：print /x var</p><p>  print可以显示被调试的语言中任何有效的表达式。表达式除了包含程序中的变量外，还可以包含以下内容：<br>  a). 对程序中函数的调用</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print find_entry(1,0)</span><br></pre></td></tr></table></figure><p>  b).数据结构和其他复杂对象</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *table_start</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; 8=&#123;e=reference=’\000’,location=0x0,next=0x0&#125;</span><br></pre></td></tr></table></figure><p>  c).值的历史成分</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print $1  # $1为历史记录变量，在以后可以直接引用 $1 的值</span><br></pre></td></tr></table></figure><p>  d).人为数组</p><p>  人为数组提供了一种去显示存储器块（数组节或动态分配的存储区）内容的方法。早期的调试程序没有很好的方法将任意的指针换成一个数组。就像对待参数一样，让我们查看内存中在变量h后面的10个整数，一个动态数组的语法如下所示：  </p><p>  base@length  </p><p>  因此，要想显示在h后面的10个元素，可以使用h@10：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print h@10</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; $13=(-1,345,23,-234,0,0,0,98,345,10)</span><br></pre></td></tr></table></figure><p>  e).给变量赋值  </p><p>  print除了显示一个变量的值外，还可以用来赋值，如：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print var=1</span><br></pre></td></tr></table></figure></li><li><p>info（简写i）：</p><p>  info break：显示断点信息，下面断点部分详述。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br></pre></td></tr></table></figure><p>  info local：显示当前函数中的局部变量信息。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info local</span><br></pre></td></tr></table></figure><p>  info var：显示所有的全局和静态变量名称。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info var</span><br></pre></td></tr></table></figure><p>  info func：显示所有的函数名称。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info func</span><br></pre></td></tr></table></figure><p>  info prog：显示被调试程序的执行状态。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info prog</span><br></pre></td></tr></table></figure><p>  info files：显示被调试文件的详细信息。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info files</span><br></pre></td></tr></table></figure><p>  info watchpoints: 显示所有观测点</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info watchpoints</span><br></pre></td></tr></table></figure><p>  whatis：显示变量的类型<br>  如程序中定义struct timeval var；</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) whatis var</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; type = struct timeval</span><br></pre></td></tr></table></figure></li></ul><pre><code>ptype：比whatis的功能更强，它可以提供一个结构的定义<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype var</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; type = struct timeval&#123;</span><br><span class="line">__time_t tv_sec;</span><br><span class="line">__suseconds_t tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>examine: 查看内存中的值</p><p>  命令的格式为：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x[/p] addr</span><br></pre></td></tr></table></figure><p>  其中：  </p><blockquote><p>addr： 内存地址，<br>p： 可选参数，可以为 n、f 和u，其中：</p><blockquote><p>n： 为正整数，表示需要显示 n 个地址的内容<br>f： 控制显示格式，包括:</p><blockquote><p>s：以字符串形式显示<br>i：以指令格式显示</p></blockquote><p>u： 表示从当前地址往后请求的字节数，默认为4自己，包括：</p><blockquote><p>b： 单字节<br>h： 双字节<br>w： 四字节<br>g： 八字节</p></blockquote></blockquote></blockquote></li></ul><h2 id="3-暂停执行"><a href="#3-暂停执行" class="headerlink" title="3. 暂停执行"></a>3. 暂停执行</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul><li><p>break（简写b）：在调试的程序中设置断点</p><p>  该命令有如下四种形式：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break line_number     # 使程序在执行给定行之前停止。</span><br><span class="line">(gdb) break function_name   # 使程序在进入指定的函数之前停止。</span><br><span class="line">(gdb) break line-or-function if condition    # 如果condition（条件）是真，程序到达指定行或函数时停止。</span><br><span class="line">(gdb) break routine-name    # 在指定例程的入口处设置断点</span><br><span class="line">(gdb) break *address        # 在程序的运行地址处停止</span><br><span class="line">(gdb) break                 # 没有参数，则在下一句停止</span><br></pre></td></tr></table></figure><p>  多源文件中设置断点：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break filename:line-number</span><br><span class="line">(gdb) break filename:function-name</span><br></pre></td></tr></table></figure></li><li><p>break if：条件断点，满足特定条件后才会中断</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break line-or-function if (condition)</span><br></pre></td></tr></table></figure><p>  例如：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 46 if testsize==100</span><br></pre></td></tr></table></figure></li><li><p>break thread：线程中断</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [line_number] thread [thread_number] [if ...]</span><br></pre></td></tr></table></figure><p>  其中： line_number：断点设置所在代码行号<br>  thread_number：线程的ID。由GDB分配，通过info threads查看运行中程序的线程信息。<br>  if …：设置中断条件。</p></li><li><p>condition（简写cond）：与break if 类似，只是condition只能用在已存在的断点上</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) condition &lt;break_list&gt; (condition)</span><br></pre></td></tr></table></figure><p>  例如：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cond 3 i==3</span><br></pre></td></tr></table></figure><p>  将在断点3上附加条件(i==3)<br>  tbreak（简写tb）：临时断点，中断一次后自动删除断点，形式参照break</p></li></ul><h3 id="断点的管理"><a href="#断点的管理" class="headerlink" title="断点的管理"></a>断点的管理</h3><ul><li><p>显示当前gdb的断点信息info(简写i)：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br></pre></td></tr></table></figure><p>  或</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i b</span><br></pre></td></tr></table></figure><p>  它会以如下的形式显示所有的断点信息：</p><p>  | Num   | Type       | Disp  | Enb   | Address    | What                           |<br>  | :—: | :——–: | :—: | :—: | :——–: | :—————————-: |<br>  | 1     | breakpoint | keep  | y     | 0x000028bc | in init_random at qsort2.c:155 |<br>  | 2     | breakpoint | keep  | y     | 0x0000291c | in init_organ at qsort2.c:168  |</p><p>  其中：  </p><blockquote><p>Num：断点号<br>Type：断点类型（断点、监视点、捕获点）<br>Disp：断点部署（该断点下次中断后该如何处理该断点）<br>keep：保持不变<br>del： 删除该断点<br>dis： 禁用该断点<br>Enb：断点当前启用状态<br>What：断点位置  </p></blockquote></li><li><p>删除断点 delete (简写 d )：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoint 1</span><br></pre></td></tr></table></figure><p>  删除编号为 1 的断点，如果不带编号参数，将删除所有的断点</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoint</span><br></pre></td></tr></table></figure></li><li><p>禁止使用某个断点</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable breakpoint 1</span><br></pre></td></tr></table></figure><p>  禁止断点 1，断点信息的 (Enb)域将变为 n</p></li><li><p>允许使用某个断点</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) enable breakpoint 1</span><br></pre></td></tr></table></figure><p>  允许断点 1，断点信息的 (Enb)域将变为 y</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) enable once breakpoint 1</span><br></pre></td></tr></table></figure><p>  断点1中断一次后自动禁用</p></li><li><p>删除刚才停止处的断点</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear</span><br></pre></td></tr></table></figure></li><li><p>清除某一代码行上的所有断点</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [filename:]line_number</span><br></pre></td></tr></table></figure></li><li><p>清除某一函数的断点</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [filename:]function_name</span><br></pre></td></tr></table></figure></li><li><p>移动断点</p><p>  gdb中移动断点的唯一方法是删除断点后在新的位置再放置一个一模一样的断点，但ddd中只需要拖曳断点符号就可以移动新的断点，并且保留该断点的所有属性。</p></li></ul><h3 id="为断点设置命令列表"><a href="#为断点设置命令列表" class="headerlink" title="为断点设置命令列表"></a>为断点设置命令列表</h3><p>通常，设置一个断点并且在上面中断后，一般会查询一些变量或做一些其他动作。使用命令列表(commands)就能使程序到达断点后自动执行这些动作。</p><p>步骤如下：</p><ol><li>建立断点</li><li>使用commands命令，用法(gdb)command break_list，如： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) commands 1</span><br><span class="line"></span><br><span class="line">Type commands for when breakpoint 1 is hit, one per line.</span><br><span class="line">End with a line saying just "end".</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>silent</span><br><span class="line"><span class="meta">&gt;</span>printf "n = %d\n", n</span><br><span class="line"><span class="meta">&gt;</span>continue</span><br><span class="line"><span class="meta">&gt;</span>end</span><br></pre></td></tr></table></figure></li></ol><h3 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h3><ul><li><p>display: 监视某个变量，并且每次都停下都显示该变量值</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display i</span><br></pre></td></tr></table></figure></li><li><p>watch expr：监视变量的变化达到条件时停止程序执行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch i&gt;99</span><br></pre></td></tr></table></figure></li><li><p>rwatch expr: 当表达式expr被读时，停止程序</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) rwatch i</span><br></pre></td></tr></table></figure></li><li><p>awatch expr: 当表达式的值被读或写时，停止程序</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) awatch i</span><br></pre></td></tr></table></figure><p>  <code>注意：监视点的设定不依赖于断点的位置，但是与变量的作用域有关。也就是说，要设置监视点必须在程序运行时才可设置。</code></p><p>  在循环中我们也可以使用 watch ，配合 ignore ，它是除了 until 命令之外又一个可以让我们跳出循环的方法，<code>不过 watch + ignore 更强大，可以任意跳转到第 i 次循环</code>。它们的意思就是观察一个变量，可以理解为断点，ignore 这个断点多少次，然后用 continue 就可以直接跳过了。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch i</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Hardware watchpoint 3: i</span><br><span class="line">(gdb) ignore 3 15   # 忽略第三个观测点15次</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Will ignore next 15 crossings of breakpoint 3.</span><br></pre></td></tr></table></figure></li></ul><h3 id="捕捉点"><a href="#捕捉点" class="headerlink" title="捕捉点"></a>捕捉点</h3><ul><li>catch event：当event发生时，停止执行程序<br>  event可为以下情况：<blockquote><p>throw：一个C++抛出的异常（throw为关键字）<br>catch：一个C++捕捉到的异常(catch为关键字)<br>exec：调用系统调用exec时（exec为关键字，目前此功能只在HP-UX下有用）<br>fork：调用系统调用fork时（fork为关键字，目前此功能只在HP-UX下有用）<br>vfork：调用系统调用vfork时（vfork为关键字，目前此功能只在HP-UX下有用）<br>load 或 load 载入共享库（动态链接库）时（load为关键字，目前此功能只在HP-UX下有用）<br>unload 或 unload 卸载共享库（动态链接库）时（unload为关键字，目前此功能只在HP-UX下有用）</p></blockquote></li></ul><h2 id="4-恢复执行"><a href="#4-恢复执行" class="headerlink" title="4. 恢复执行"></a>4. 恢复执行</h2><ul><li><p>next（简写n）：不进入的单步执行，且执行n步</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next [n]</span><br></pre></td></tr></table></figure></li><li><p>step（简写s）：进入的单步执行，且执行n步</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) step [n]</span><br></pre></td></tr></table></figure></li><li><p>continue（简写c）：从断点继续运行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) continue [n]</span><br></pre></td></tr></table></figure><p>  参数n使gdb忽略接下来的n个断点。</p></li><li><p>finish：程序已经进入了某函数，执行finish退出该函数返回到它的调用函数中</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br></pre></td></tr></table></figure></li><li><p>until：无参的until命令恢复程序的运行，并执行完循环的其余部分</p><p>  until官方定义：执行程序，直到到达当前循环体外的下一行源代码<br>  实际上，由于高级语言到机器语言在顺序上并不一定完全对应，until在到达内存地址比当前高的机器指令后就会停止<br>  用法：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">until [filename:]line_number</span><br><span class="line">until [filename:]function</span><br></pre></td></tr></table></figure><p>  以上两种用法在到达指定的行号或者函数后即停止。</p></li></ul><h2 id="5-变量赋值"><a href="#5-变量赋值" class="headerlink" title="5. 变量赋值"></a>5. 变量赋值</h2><p>除了使用 print 给变量赋值，还可以使用 set variable 命令赋值。</p><ul><li><p>set variable：给变量赋值</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set variable i=1</span><br></pre></td></tr></table></figure></li><li><p>set env environment Varname=value ： 设置环境变量</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set env USER=benben</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-函数调用"><a href="#6-函数调用" class="headerlink" title="6. 函数调用"></a>6. 函数调用</h2><ul><li><p>call func_name：调用和执行一个函数</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call gen_and_sork(1234, 1, 0)</span><br><span class="line">(gdb) call printf(“abcd\n”)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; abcd</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; $1=4</span><br></pre></td></tr></table></figure></li><li><p>jump：在源程序中的另一点开始运行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) jump line_number</span><br></pre></td></tr></table></figure><p>  line_number 可以是 linenum，filename+linenum，+ offset 这几种形式</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) jump address  # 跳到代码行的地址</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-栈信息"><a href="#7-栈信息" class="headerlink" title="7. 栈信息"></a>7. 栈信息</h2><ul><li><p>backtrace（简写bt）：为堆栈提供向后跟踪功能</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace [-n] [n]  # 显示程序中的当前位置和表示如何到达当前位置的栈跟踪。</span><br></pre></td></tr></table></figure><p>  其中：</p><blockquote><p>-n：表示只打印栈底上n层的栈信息<br>n：表示只打印栈顶上n层的栈信息</p></blockquote><p>  不加参数，表示打印所有栈信息。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) down  # 下移栈帧，使得另一个函数成为当前函数</span><br><span class="line">(gdb) up    # 上移栈帧，使另一函数成为当前函数</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-信号"><a href="#8-信号" class="headerlink" title="8. 信号"></a>8. 信号</h2><ul><li><p>handle signals [argu]：捕捉信号</p><p>  signals：是Linux/Unix定义的信号，如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号等等。</p><p>  argu：</p><blockquote><p>nostop：接收到信号时，GDB不会停止程序的运行，但会打出消息通知收到这种信号。<br>stop：接受到信号时停止程序的执行，允许程序调试；显示一条表示已接受到信号的消息（禁止使用消息除外）。<br>print：接受到信号时显示一条消息。<br>noprint：接受到信号时不要显示消息。<br>pass or noignore：接收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序处理。<br>nopass or ignore：接收到信号时，GDB不会让调试程序来处理这个信号。</p></blockquote><p>  例如，假定截获SIGPIPE信号，以防止正在调试的程序接受到该信号，而且只要该信号一到达，就要求该程序停止，并通知你。要完成这一任务，可利用如下命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) handle SIGPIPE stop print</span><br></pre></td></tr></table></figure><p>  <code>UNIX的信号名总是采用大写字母</code>。可以用信号编号替代信号名。  </p><p>  如果程序要测试其信号处理程序，就需要一种能将信号发送给程序的简便方法：signal命令。<br>  signal命令的参数是一个数字或者一个名字，如SIGINT。假定程序已将一个专用的SIGINT（键盘输入，或CTRL-C；信号2）信号处理程序设置成某个动作，要测试该信号处理程序，可设置一个断点并使用如下命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) signal 2</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; continuing with signal SIGINT(2)</span><br></pre></td></tr></table></figure><p>  该程序继续执行，但是立即传输该信号，而且处理程序开始运行。</p></li></ul><h2 id="9-字段搜索"><a href="#9-字段搜索" class="headerlink" title="9. 字段搜索"></a>9. 字段搜索</h2><ul><li><p>search text：至上往下搜索，显示在当前文件中包含text的代码行</p></li><li><p>reverse-search text：至下往上搜索，显示包含text的代码行</p></li></ul><h2 id="10-UNIX接口"><a href="#10-UNIX接口" class="headerlink" title="10. UNIX接口"></a>10. UNIX接口</h2><ul><li><p>shell：使可不用离开gdb下启动unix外壳，即暂时退出gdb调试回到用户控制终端</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell</span><br></pre></td></tr></table></figure></li><li><p>exit（快捷键ctrl+d）：退出unix外壳，返回到 gdb</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-工作目录"><a href="#11-工作目录" class="headerlink" title="11. 工作目录"></a>11. 工作目录</h2><ul><li><p>cd：改变工作目录</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cd [path]</span><br></pre></td></tr></table></figure></li><li><p>pwd：显示工作目录</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) pwd</span><br></pre></td></tr></table></figure></li></ul><h2 id="12-机器语言工具"><a href="#12-机器语言工具" class="headerlink" title="12. 机器语言工具"></a>12. 机器语言工具</h2><p>有一组专用的gdb变量可以用来检查和修改计算机的通用寄存器，gdb提供了目前每一台计算机中实际使用的4个寄存器的标准名字：</p><ul><li>$pc ： 程序计数器</li><li>$fp ： 帧指针（当前堆栈帧）</li><li>$sp ： 栈指针</li><li>$ps ： 处理器状态</li></ul><h2 id="13-命令的历史"><a href="#13-命令的历史" class="headerlink" title="13. 命令的历史"></a>13. 命令的历史</h2><p>为了允许使用历史命令，可使用 set history expansion on 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set history expansion on</span><br></pre></td></tr></table></figure><h2 id="14-查看机器码"><a href="#14-查看机器码" class="headerlink" title="14. 查看机器码"></a>14. 查看机器码</h2><ul><li><p>disassemble： 查看执行时源代码的机器码</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble b.func</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt;</span><br><span class="line">0x00005555555549b8 &lt;+0&gt;:    push   %rbp</span><br><span class="line">0x00005555555549b9 &lt;+1&gt;:    mov    %rsp,%rbp</span><br><span class="line">0x00005555555549bc &lt;+4&gt;:    sub    $0x20,%rsp</span><br><span class="line">0x00005555555549c0 &lt;+8&gt;:    mov    %rdi,-0x18(%rbp)</span><br><span class="line">0x00005555555549c4 &lt;+12&gt;:   mov    %esi,-0x1c(%rbp)</span><br><span class="line">0x00005555555549c7 &lt;+15&gt;:   movl   $0x0,-0x4(%rbp)</span><br><span class="line">0x00005555555549ce &lt;+22&gt;:   mov    -0x4(%rbp),%eax</span><br><span class="line">0x00005555555549d1 &lt;+25&gt;:   cmp    -0x1c(%rbp),%eax</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h1 id="四、多进程调试"><a href="#四、多进程调试" class="headerlink" title="四、多进程调试"></a>四、多进程调试</h1><p>在进行多进程调试的时候，我们在 fork() 函数后的父进程与子进程代码段内分别设有断点并运行调试的时候会发现，父进程能够在断点处正常停止，而子进程会忽略断点继续运行，因此需要一定的手段调试多进程程序。</p><h2 id="1-使用调试器选项-follow-fork-mode-和-detach-on-fork"><a href="#1-使用调试器选项-follow-fork-mode-和-detach-on-fork" class="headerlink" title="1. 使用调试器选项 follow-fork-mode 和 detach-on-fork"></a>1. 使用调试器选项 follow-fork-mode 和 detach-on-fork</h2><ul><li><p>follow-fork-mode 选项</p><p>  用于选择调试指定进程，但只能同时调试其中一个进程，另一个进程会忽略断点继续运行。命令格式为：  </p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode mode</span><br></pre></td></tr></table></figure><p>  其中 mode 的可选值是：</p><blockquote><p>parent： 仅调试父进程，默认值<br>child： 仅调试子进程</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set follow-fork-mode child</span><br></pre></td></tr></table></figure><p>  此时 gdb 将调试子进程，并忽略父进程的断点。若想同时调试父/子进程，则需要使用 detach-on-fork 选项。</p></li><li><p>detach-on-fork 选项</p><p>  指示 GDB 在 fork 之后是否断开（detach）某个进程的调试，或者都交由 GDB 控制。命令格式为：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set detach-on-fork mode</span><br></pre></td></tr></table></figure><p>  其中 mode 的可选值是：</p><blockquote><p>off： 断开（可同时调试）<br>on： 断开（不能同时调试），默认值  </p></blockquote><p>  当 mode 为 off 时，其中某个进程将会<code>阻塞</code>在 fork 位置，具体如下表所示：</p><p>  | follow-fork-mode | detach-on-fork | 说明                                                 |<br>  | :————–: | :————: | :————————————————–: |<br>  | parent           | on             | 只调试父进程（GDB默认）                              |<br>  | child            | on             | 只调试子进程                                         |<br>  | parent           | off            | 同时调试两个进程，gdb 调试父进程，子进程 block 在 fork 位置 |<br>  | child            | off            | 同时调试两个进程，gdb 调试子进程，父进程 block 在 fork 位置 |</p><p>  即，若要同时调试两个进程，可以进行如下设置：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set follow-fork-mode child    # 调试子进程</span><br><span class="line">(gdb) set detach-on-fork off        # 关闭进程分离，同时调试父进程（父进程默认阻塞在 fork 函数）</span><br><span class="line">(gdb) b 18                          # 在子进程代码区设断点</span><br><span class="line">(gdb) r</span><br></pre></td></tr></table></figure><p>  <code>注</code>：该方法并不适合所有 Linux， 因此需要采用其他方法。</p></li></ul><h2 id="2-使用-attach-命令"><a href="#2-使用-attach-命令" class="headerlink" title="2. 使用 attach 命令"></a>2. 使用 attach 命令</h2><p>众所周知，GDB 有附着（attach）到正在运行的进程的功能，即 attach \&lt; pid > 命令。因此我们可以利用该命令 attach 到子进程然后进行调试。</p><p>首先我们需要查看运行程序的进程ID，使用如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep test</span><br></pre></td></tr></table></figure><p>查找到你运行的程序的PID，并在 gdb 下使用 attach 命令可以附着在该进程下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach PID  # 其中，PID是要调试的进程ID</span><br></pre></td></tr></table></figure><p>被成功附着的进程将直接暂停执行，此时你可以正常来调试。</p><p>脱离进程使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) detach</span><br></pre></td></tr></table></figure><p><code>注</code>：部分 Linux 需要在<code>超级用户</code>下运行 gdb 才能 attach 成功。</p><p>一个新的问题是，<strong><code>子进程一直在运行，attach上去后都不知道运行到哪里了。有没有办法解决呢？</code></strong></p><p>至于这段代码所采用的条件，看你的偏好了。比如我们可以在需要调试的进程（可以同时调试多个进程）的代码处添加个<code>无限循环</code>并配合 sleep 函数，然后配合使用 jump、next 命令或者其他修改变量的命令如 set 改变循环条件退出循环。以 jump 为例，其形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent ID： "</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">... <span class="comment">// 其他代码，使用 jump 跳转至此</span></span><br></pre></td></tr></table></figure><h1 id="五、多线程调试"><a href="#五、多线程调试" class="headerlink" title="五、多线程调试"></a>五、多线程调试</h1><p>gdb调试一般有两种模式：all-stop模式和no-stop模式（gdb7.0之前不支持no-stop模式）。</p><ul><li><p>all-stop 模式</p><p>  在这种模式下，<code>当你的程序在gdb由于任何原因而停止，所有的线程都会停止</code>，而不仅仅是当前的线程。一般来说，gdb不能单步所有的线程。因为线程调度是gdb无法控制的。<code>无论什么时候当gdb停止你的程序，它都会自动切换到触发断点的那个线程</code>。</p></li><li><p>no-stop模式（网络编程常用）</p><p>  当程序在gdb中停止，只有当前的线程会被停止，而其他线程将会继续运行。这时候step，next这些命令就只对当前线程起作用。</p></li></ul><p>如果要打开 no-stop 模式，可以进行如下设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>Enable the async interface</span><br><span class="line">(gdb) set target-async 1</span><br><span class="line"><span class="meta">#</span>If using the CLI, pagination breaks non-stop</span><br><span class="line">(gdb) set pagination off</span><br><span class="line"><span class="meta">#</span>Finall, turn it on</span><br><span class="line">(gdb) set non-stop on</span><br></pre></td></tr></table></figure><p>gdb 支持的命里有两种类型：前台的（同步的）和后台（异步 ）的。区别很简单，同步的在输出提示符之前会等待程序 report 一些线程已经终止的信息，异步则是直接返回。所以我们需要 set target-async 1。set pagination off 可以不让线程结束的时候出现 Type &lt; return &gt; to continue 的提示信息 。最后一步是打开。</p><p>下面是常用命令：</p><ul><li><p>info threads</p><p>  显示所有线程。</p></li><li><p>thread id</p><p>  切换到指定线程。</p></li><li><p>break FileName.cpp:LinuNum thread all</p><p>  所有线程都在文件 FileName.cpp 的第 LineNum 行有断点。</p></li><li><p>thread apply ID1 ID2 IDN command</p><p>  让线程编号是 ID1，ID2… 等等的线程都执行 command 命令。</p></li><li><p>thread apply all command</p><p>  所有线程都执行 command 命令。</p></li><li><p>set scheduler-locking off|on|step：</p><p>  在调式某一个线程时，其他线程是否执行。在使用 step 或 continue 命令调试当前被调试线程的时候，其他线程也是同时执行的，如果我们只想要被调试的线程执行，而其他线程停止等待，那就要锁定要调试的线程，只让他运行。其中：</p><blockquote><p>off：不锁定任何线程，默认值。<br>on：锁定其他线程，只有当前线程执行。<br>step：在 step （单步）时，只有被调试线程运行。</p></blockquote></li><li><p>set non-stop on/off</p><p>  当调式一个线程时，其他线程是否运行。</p></li><li><p>set pagination on/off</p><p>  在使用 backtrace 时，在分页时是否停止。</p></li><li><p>set target-async on/off</p><p>  是否开启同步和异步。其中：</p><blockquote><p>on：同步，gdb 在输出提示符之前等待程序报告一些线程已经终止的信息。<br>off： 异步，线程结束后则是直接返回。</p></blockquote></li><li><p>show scheduler-locking</p><p>  查看当前锁定线程的模式。</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/water_cow/article/details/7214054" title="GDB基本命令(整合)" target="_blank" rel="noopener">GDB 基本命令(整合)</a></li><li><a href="https://blog.csdn.net/freeelinux/article/details/53700266" title="GDB常用调试命令以及多进程多线程调试" target="_blank" rel="noopener">GDB 常用调试命令以及多进程多线程调试</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/" title="使用 GDB 调试多进程程序" target="_blank" rel="noopener">使用 GDB 调试多进程程序</a></li><li><a href="https://blog.csdn.net/snow_5288/article/details/72982594" title="gdb调试多进程与多线程" target="_blank" rel="noopener">gdb调试多进程与多线程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该内容主要是把几个参考的博客内容进行整理和补充，并采用markdown语法对原博客内容重写&lt;/p&gt;
&lt;h1 id=&quot;一、GDB-调试基本知识&quot;&gt;&lt;a href=&quot;#一、GDB-调试基本知识&quot; class=&quot;headerlink&quot; title=&quot;一、GDB 调试基本知识&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://letmily.gitee.io/tags/Linux/"/>
    
      <category term="GDB" scheme="https://letmily.gitee.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>TEST</title>
    <link href="https://letmily.gitee.io/2018/07/10/test/"/>
    <id>https://letmily.gitee.io/2018/07/10/test/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-08-20T15:54:44.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h2><p><img src="/images/articles/test/1.jpeg" height="300" align="center/"></p><a id="more"></a><h2 id="测试"><a href="#测试" class="headerlink" title="``测试"></a>``测试</h2><p><code>你好</code></p>]]></content>
    
    <summary type="html">
    
      一些简单的测试
    
    </summary>
    
    
      <category term="test" scheme="https://letmily.gitee.io/tags/test/"/>
    
  </entry>
  
</feed>
