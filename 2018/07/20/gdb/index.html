<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar/avatar32.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar/avatar16.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    fastclick: true,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="该内容主要是把几个参考的博客内容进行整理和补充，并采用markdown语法对原博客内容重写 一、GDB 调试基本知识 调试器指示的是将要执行的代码行 只有在编译时拥有调试符号(-g)的程序才能在调试时看到源码 同一行上有多个断点时，gdb仅中断在断点号最小的那个断点上 断点可以设置在同一程序的不同文件中 在任何给定时间，gdb只有一个焦点，即当前“活动”的文件 源文件改变后，断点发生移动，带式断点">
<meta name="keywords" content="Linux,GDB">
<meta property="og:type" content="article">
<meta property="og:title" content="GDB 基本用法，以及多进程、多线程的调试">
<meta property="og:url" content="https://letmily.gitee.io/2018/07/20/gdb/index.html">
<meta property="og:site_name" content="Deemo的博客">
<meta property="og:description" content="该内容主要是把几个参考的博客内容进行整理和补充，并采用markdown语法对原博客内容重写 一、GDB 调试基本知识 调试器指示的是将要执行的代码行 只有在编译时拥有调试符号(-g)的程序才能在调试时看到源码 同一行上有多个断点时，gdb仅中断在断点号最小的那个断点上 断点可以设置在同一程序的不同文件中 在任何给定时间，gdb只有一个焦点，即当前“活动”的文件 源文件改变后，断点发生移动，带式断点">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-20T16:21:03.516Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GDB 基本用法，以及多进程、多线程的调试">
<meta name="twitter:description" content="该内容主要是把几个参考的博客内容进行整理和补充，并采用markdown语法对原博客内容重写 一、GDB 调试基本知识 调试器指示的是将要执行的代码行 只有在编译时拥有调试符号(-g)的程序才能在调试时看到源码 同一行上有多个断点时，gdb仅中断在断点号最小的那个断点上 断点可以设置在同一程序的不同文件中 在任何给定时间，gdb只有一个焦点，即当前“活动”的文件 源文件改变后，断点发生移动，带式断点">



  <link rel="alternate" href="/atom.xml" title="Deemo的博客" type="application/atom+xml" />




  <link rel="canonical" href="https://letmily.gitee.io/2018/07/20/gdb/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>GDB 基本用法，以及多进程、多线程的调试 | Deemo的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deemo的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://letmily.gitee.io/2018/07/20/gdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leitmily">
      <meta itemprop="description" content="go go fighting!">
      <meta itemprop="image" content="/images/avatar/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deemo的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GDB 基本用法，以及多进程、多线程的调试
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-20 00:15:36" itemprop="dateCreated datePublished" datetime="2018-07-20T00:15:36+08:00">2018-07-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-21 00:21:03" itemprop="dateModified" datetime="2018-08-21T00:21:03+08:00">2018-08-21</time>
              
            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>该内容主要是把几个参考的博客内容进行整理和补充，并采用markdown语法对原博客内容重写</p>
<h1 id="一、GDB-调试基本知识"><a href="#一、GDB-调试基本知识" class="headerlink" title="一、GDB 调试基本知识"></a>一、GDB 调试基本知识</h1><ol>
<li>调试器指示的是将要执行的代码行</li>
<li>只有在编译时拥有调试符号(-g)的程序才能在调试时看到源码</li>
<li>同一行上有多个断点时，gdb仅中断在断点号最小的那个断点上</li>
<li>断点可以设置在同一程序的不同文件中</li>
<li>在任何给定时间，gdb只有一个焦点，即当前“活动”的文件</li>
<li>源文件改变后，断点发生移动，带式断点属性的行号不变</li>
</ol>
<h1 id="二、GDB-基本命令清单查询"><a href="#二、GDB-基本命令清单查询" class="headerlink" title="二、GDB 基本命令清单查询"></a>二、GDB 基本命令清单查询</h1><p>在 gdb 提示符处键入help，将列出命令的分类，主要的分类有： </p>
<ul>
<li>aliases：命令别名</li>
<li>breakpoints：断点定义</li>
<li>data：数据查看</li>
<li>files：指定并查看文件</li>
<li>internals：维护命令</li>
<li>running：程序执行</li>
<li>stack：调用栈查看</li>
<li>statu：状态查看</li>
<li>tracepoints：跟踪程序执行</li>
</ul>
<p>键入 help 后跟命令的分类名（如help aliases），可获得该类命令的详细清单。</p>
<h1 id="三、GDB-基本命令用法"><a href="#三、GDB-基本命令用法" class="headerlink" title="三、GDB 基本命令用法"></a>三、GDB 基本命令用法</h1><h2 id="1-运行和退出"><a href="#1-运行和退出" class="headerlink" title="1. 运行和退出"></a>1. 运行和退出</h2><ul>
<li><p><strong>run（简写r）：执行程序</strong></p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run app [argv1] [argv2] ...</span><br></pre></td></tr></table></figure>
<p>  run命令后可跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt;)和外壳通配符（*、？、[、]）在内。<br>  如果使用不带参数的run命令，gdb就再次使用前一条run命令的参数。</p>
</li>
<li><p><strong>set args：设定传递给程序的参数</strong></p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args [argv1] [argv2] ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>show args：查看其缺省参数的列表</strong></p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show follow-fork-mode     # 显示参数 follow-fork-mode 选项的值</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>kill（简写k）：异常终止在gdb 控制下运行的程序</strong></p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) kill</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>quit（简写q）：退出gdb</strong></p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-查看信息"><a href="#2-查看信息" class="headerlink" title="2. 查看信息"></a>2. 查看信息</h2><ul>
<li><p><strong>list（简写l）：查看源码</strong></p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list line_num</span><br></pre></td></tr></table></figure>
<p>  或</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l line_num</span><br></pre></td></tr></table></figure>
<p>  其中line_num 为行号。</p>
<p>  查看指定文件源码：</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list file_name:line_num</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pirnt(简写p)：</strong></p>
<p>  print var：查看变量var的值。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print var</span><br></pre></td></tr></table></figure>
<p>  可以通过添加参数来设置输出格式：</p>
<blockquote>
<p>/x 按十六进制格式显示变量<br>/d 按十进制格式显示变量<br>/u 按十六进制格式显示无符号整型<br>/o 按八进制格式显示变量<br>/t 按二进制格式显示变量<br>/a 按十六进制格式显示变量<br>/c 按字符格式显示变量<br>/f 按浮点数格式显示变量</p>
</blockquote>
<p>  例如：print /x var</p>
<p>  print可以显示被调试的语言中任何有效的表达式。表达式除了包含程序中的变量外，还可以包含以下内容：<br>  a). 对程序中函数的调用</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print find_entry(1,0)</span><br></pre></td></tr></table></figure>
<p>  b).数据结构和其他复杂对象</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *table_start</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; 8=&#123;e=reference=’\000’,location=0x0,next=0x0&#125;</span><br></pre></td></tr></table></figure>
<p>  c).值的历史成分</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print $1  # $1为历史记录变量，在以后可以直接引用 $1 的值</span><br></pre></td></tr></table></figure>
<p>  d).人为数组</p>
<p>  人为数组提供了一种去显示存储器块（数组节或动态分配的存储区）内容的方法。早期的调试程序没有很好的方法将任意的指针换成一个数组。就像对待参数一样，让我们查看内存中在变量h后面的10个整数，一个动态数组的语法如下所示：  </p>
<p>  base@length  </p>
<p>  因此，要想显示在h后面的10个元素，可以使用h@10：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print h@10</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; $13=(-1,345,23,-234,0,0,0,98,345,10)</span><br></pre></td></tr></table></figure>
<p>  e).给变量赋值  </p>
<p>  print除了显示一个变量的值外，还可以用来赋值，如：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print var=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>info（简写i）：</p>
<p>  info break：显示断点信息，下面断点部分详述。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br></pre></td></tr></table></figure>
<p>  info local：显示当前函数中的局部变量信息。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info local</span><br></pre></td></tr></table></figure>
<p>  info var：显示所有的全局和静态变量名称。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info var</span><br></pre></td></tr></table></figure>
<p>  info func：显示所有的函数名称。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info func</span><br></pre></td></tr></table></figure>
<p>  info prog：显示被调试程序的执行状态。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info prog</span><br></pre></td></tr></table></figure>
<p>  info files：显示被调试文件的详细信息。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info files</span><br></pre></td></tr></table></figure>
<p>  info watchpoints: 显示所有观测点</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info watchpoints</span><br></pre></td></tr></table></figure>
<p>  whatis：显示变量的类型<br>  如程序中定义struct timeval var；</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) whatis var</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; type = struct timeval</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>ptype：比whatis的功能更强，它可以提供一个结构的定义
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype var</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; type = struct timeval&#123;</span><br><span class="line">__time_t tv_sec;</span><br><span class="line">__suseconds_t tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>examine: 查看内存中的值</p>
<p>  命令的格式为：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x[/p] addr</span><br></pre></td></tr></table></figure>
<p>  其中：  </p>
<blockquote>
<p>addr： 内存地址，<br>p： 可选参数，可以为 n、f 和u，其中：</p>
<blockquote>
<p>n： 为正整数，表示需要显示 n 个地址的内容<br>f： 控制显示格式，包括:</p>
<blockquote>
<p>s：以字符串形式显示<br>i：以指令格式显示</p>
</blockquote>
<p>u： 表示从当前地址往后请求的字节数，默认为4自己，包括：</p>
<blockquote>
<p>b： 单字节<br>h： 双字节<br>w： 四字节<br>g： 八字节</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="3-暂停执行"><a href="#3-暂停执行" class="headerlink" title="3. 暂停执行"></a>3. 暂停执行</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul>
<li><p>break（简写b）：在调试的程序中设置断点</p>
<p>  该命令有如下四种形式：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break line_number     # 使程序在执行给定行之前停止。</span><br><span class="line">(gdb) break function_name   # 使程序在进入指定的函数之前停止。</span><br><span class="line">(gdb) break line-or-function if condition    # 如果condition（条件）是真，程序到达指定行或函数时停止。</span><br><span class="line">(gdb) break routine-name    # 在指定例程的入口处设置断点</span><br><span class="line">(gdb) break *address        # 在程序的运行地址处停止</span><br><span class="line">(gdb) break                 # 没有参数，则在下一句停止</span><br></pre></td></tr></table></figure>
<p>  多源文件中设置断点：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break filename:line-number</span><br><span class="line">(gdb) break filename:function-name</span><br></pre></td></tr></table></figure>
</li>
<li><p>break if：条件断点，满足特定条件后才会中断</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break line-or-function if (condition)</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 46 if testsize==100</span><br></pre></td></tr></table></figure>
</li>
<li><p>break thread：线程中断</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [line_number] thread [thread_number] [if ...]</span><br></pre></td></tr></table></figure>
<p>  其中： line_number：断点设置所在代码行号<br>  thread_number：线程的ID。由GDB分配，通过info threads查看运行中程序的线程信息。<br>  if …：设置中断条件。</p>
</li>
<li><p>condition（简写cond）：与break if 类似，只是condition只能用在已存在的断点上</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) condition &lt;break_list&gt; (condition)</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cond 3 i==3</span><br></pre></td></tr></table></figure>
<p>  将在断点3上附加条件(i==3)<br>  tbreak（简写tb）：临时断点，中断一次后自动删除断点，形式参照break</p>
</li>
</ul>
<h3 id="断点的管理"><a href="#断点的管理" class="headerlink" title="断点的管理"></a>断点的管理</h3><ul>
<li><p>显示当前gdb的断点信息info(简写i)：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br></pre></td></tr></table></figure>
<p>  或</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i b</span><br></pre></td></tr></table></figure>
<p>  它会以如下的形式显示所有的断点信息：</p>
<p>  | Num   | Type       | Disp  | Enb   | Address    | What                           |<br>  | :—: | :——–: | :—: | :—: | :——–: | :—————————-: |<br>  | 1     | breakpoint | keep  | y     | 0x000028bc | in init_random at qsort2.c:155 |<br>  | 2     | breakpoint | keep  | y     | 0x0000291c | in init_organ at qsort2.c:168  |</p>
<p>  其中：  </p>
<blockquote>
<p>Num：断点号<br>Type：断点类型（断点、监视点、捕获点）<br>Disp：断点部署（该断点下次中断后该如何处理该断点）<br>keep：保持不变<br>del： 删除该断点<br>dis： 禁用该断点<br>Enb：断点当前启用状态<br>What：断点位置  </p>
</blockquote>
</li>
<li><p>删除断点 delete (简写 d )：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoint 1</span><br></pre></td></tr></table></figure>
<p>  删除编号为 1 的断点，如果不带编号参数，将删除所有的断点</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoint</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止使用某个断点</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable breakpoint 1</span><br></pre></td></tr></table></figure>
<p>  禁止断点 1，断点信息的 (Enb)域将变为 n</p>
</li>
<li><p>允许使用某个断点</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) enable breakpoint 1</span><br></pre></td></tr></table></figure>
<p>  允许断点 1，断点信息的 (Enb)域将变为 y</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) enable once breakpoint 1</span><br></pre></td></tr></table></figure>
<p>  断点1中断一次后自动禁用</p>
</li>
<li><p>删除刚才停止处的断点</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除某一代码行上的所有断点</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [filename:]line_number</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除某一函数的断点</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [filename:]function_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动断点</p>
<p>  gdb中移动断点的唯一方法是删除断点后在新的位置再放置一个一模一样的断点，但ddd中只需要拖曳断点符号就可以移动新的断点，并且保留该断点的所有属性。</p>
</li>
</ul>
<h3 id="为断点设置命令列表"><a href="#为断点设置命令列表" class="headerlink" title="为断点设置命令列表"></a>为断点设置命令列表</h3><p>通常，设置一个断点并且在上面中断后，一般会查询一些变量或做一些其他动作。使用命令列表(commands)就能使程序到达断点后自动执行这些动作。</p>
<p>步骤如下：</p>
<ol>
<li>建立断点</li>
<li>使用commands命令，用法(gdb)command break_list，如： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) commands 1</span><br><span class="line"></span><br><span class="line">Type commands for when breakpoint 1 is hit, one per line.</span><br><span class="line">End with a line saying just "end".</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>silent</span><br><span class="line"><span class="meta">&gt;</span>printf "n = %d\n", n</span><br><span class="line"><span class="meta">&gt;</span>continue</span><br><span class="line"><span class="meta">&gt;</span>end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h3><ul>
<li><p>display: 监视某个变量，并且每次都停下都显示该变量值</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display i</span><br></pre></td></tr></table></figure>
</li>
<li><p>watch expr：监视变量的变化达到条件时停止程序执行</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch i&gt;99</span><br></pre></td></tr></table></figure>
</li>
<li><p>rwatch expr: 当表达式expr被读时，停止程序</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) rwatch i</span><br></pre></td></tr></table></figure>
</li>
<li><p>awatch expr: 当表达式的值被读或写时，停止程序</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) awatch i</span><br></pre></td></tr></table></figure>
<p>  <code>注意：监视点的设定不依赖于断点的位置，但是与变量的作用域有关。也就是说，要设置监视点必须在程序运行时才可设置。</code></p>
<p>  在循环中我们也可以使用 watch ，配合 ignore ，它是除了 until 命令之外又一个可以让我们跳出循环的方法，<code>不过 watch + ignore 更强大，可以任意跳转到第 i 次循环</code>。它们的意思就是观察一个变量，可以理解为断点，ignore 这个断点多少次，然后用 continue 就可以直接跳过了。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch i</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Hardware watchpoint 3: i</span><br><span class="line">(gdb) ignore 3 15   # 忽略第三个观测点15次</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Will ignore next 15 crossings of breakpoint 3.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="捕捉点"><a href="#捕捉点" class="headerlink" title="捕捉点"></a>捕捉点</h3><ul>
<li>catch event：当event发生时，停止执行程序<br>  event可为以下情况：<blockquote>
<p>throw：一个C++抛出的异常（throw为关键字）<br>catch：一个C++捕捉到的异常(catch为关键字)<br>exec：调用系统调用exec时（exec为关键字，目前此功能只在HP-UX下有用）<br>fork：调用系统调用fork时（fork为关键字，目前此功能只在HP-UX下有用）<br>vfork：调用系统调用vfork时（vfork为关键字，目前此功能只在HP-UX下有用）<br>load 或 load 载入共享库（动态链接库）时（load为关键字，目前此功能只在HP-UX下有用）<br>unload 或 unload 卸载共享库（动态链接库）时（unload为关键字，目前此功能只在HP-UX下有用）</p>
</blockquote>
</li>
</ul>
<h2 id="4-恢复执行"><a href="#4-恢复执行" class="headerlink" title="4. 恢复执行"></a>4. 恢复执行</h2><ul>
<li><p>next（简写n）：不进入的单步执行，且执行n步</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next [n]</span><br></pre></td></tr></table></figure>
</li>
<li><p>step（简写s）：进入的单步执行，且执行n步</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) step [n]</span><br></pre></td></tr></table></figure>
</li>
<li><p>continue（简写c）：从断点继续运行</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) continue [n]</span><br></pre></td></tr></table></figure>
<p>  参数n使gdb忽略接下来的n个断点。</p>
</li>
<li><p>finish：程序已经进入了某函数，执行finish退出该函数返回到它的调用函数中</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br></pre></td></tr></table></figure>
</li>
<li><p>until：无参的until命令恢复程序的运行，并执行完循环的其余部分</p>
<p>  until官方定义：执行程序，直到到达当前循环体外的下一行源代码<br>  实际上，由于高级语言到机器语言在顺序上并不一定完全对应，until在到达内存地址比当前高的机器指令后就会停止<br>  用法：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">until [filename:]line_number</span><br><span class="line">until [filename:]function</span><br></pre></td></tr></table></figure>
<p>  以上两种用法在到达指定的行号或者函数后即停止。</p>
</li>
</ul>
<h2 id="5-变量赋值"><a href="#5-变量赋值" class="headerlink" title="5. 变量赋值"></a>5. 变量赋值</h2><p>除了使用 print 给变量赋值，还可以使用 set variable 命令赋值。</p>
<ul>
<li><p>set variable：给变量赋值</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set variable i=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>set env environment Varname=value ： 设置环境变量</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set env USER=benben</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-函数调用"><a href="#6-函数调用" class="headerlink" title="6. 函数调用"></a>6. 函数调用</h2><ul>
<li><p>call func_name：调用和执行一个函数</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call gen_and_sork(1234, 1, 0)</span><br><span class="line">(gdb) call printf(“abcd\n”)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; abcd</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; $1=4</span><br></pre></td></tr></table></figure>
</li>
<li><p>jump：在源程序中的另一点开始运行</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) jump line_number</span><br></pre></td></tr></table></figure>
<p>  line_number 可以是 linenum，filename+linenum，+ offset 这几种形式</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) jump address  # 跳到代码行的地址</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-栈信息"><a href="#7-栈信息" class="headerlink" title="7. 栈信息"></a>7. 栈信息</h2><ul>
<li><p>backtrace（简写bt）：为堆栈提供向后跟踪功能</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace [-n] [n]  # 显示程序中的当前位置和表示如何到达当前位置的栈跟踪。</span><br></pre></td></tr></table></figure>
<p>  其中：</p>
<blockquote>
<p>-n：表示只打印栈底上n层的栈信息<br>n：表示只打印栈顶上n层的栈信息</p>
</blockquote>
<p>  不加参数，表示打印所有栈信息。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) down  # 下移栈帧，使得另一个函数成为当前函数</span><br><span class="line">(gdb) up    # 上移栈帧，使另一函数成为当前函数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="8-信号"><a href="#8-信号" class="headerlink" title="8. 信号"></a>8. 信号</h2><ul>
<li><p>handle signals [argu]：捕捉信号</p>
<p>  signals：是Linux/Unix定义的信号，如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号等等。</p>
<p>  argu：</p>
<blockquote>
<p>nostop：接收到信号时，GDB不会停止程序的运行，但会打出消息通知收到这种信号。<br>stop：接受到信号时停止程序的执行，允许程序调试；显示一条表示已接受到信号的消息（禁止使用消息除外）。<br>print：接受到信号时显示一条消息。<br>noprint：接受到信号时不要显示消息。<br>pass or noignore：接收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序处理。<br>nopass or ignore：接收到信号时，GDB不会让调试程序来处理这个信号。</p>
</blockquote>
<p>  例如，假定截获SIGPIPE信号，以防止正在调试的程序接受到该信号，而且只要该信号一到达，就要求该程序停止，并通知你。要完成这一任务，可利用如下命令：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) handle SIGPIPE stop print</span><br></pre></td></tr></table></figure>
<p>  <code>UNIX的信号名总是采用大写字母</code>。可以用信号编号替代信号名。  </p>
<p>  如果程序要测试其信号处理程序，就需要一种能将信号发送给程序的简便方法：signal命令。<br>  signal命令的参数是一个数字或者一个名字，如SIGINT。假定程序已将一个专用的SIGINT（键盘输入，或CTRL-C；信号2）信号处理程序设置成某个动作，要测试该信号处理程序，可设置一个断点并使用如下命令：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) signal 2</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; continuing with signal SIGINT(2)</span><br></pre></td></tr></table></figure>
<p>  该程序继续执行，但是立即传输该信号，而且处理程序开始运行。</p>
</li>
</ul>
<h2 id="9-字段搜索"><a href="#9-字段搜索" class="headerlink" title="9. 字段搜索"></a>9. 字段搜索</h2><ul>
<li><p>search text：至上往下搜索，显示在当前文件中包含text的代码行</p>
</li>
<li><p>reverse-search text：至下往上搜索，显示包含text的代码行</p>
</li>
</ul>
<h2 id="10-UNIX接口"><a href="#10-UNIX接口" class="headerlink" title="10. UNIX接口"></a>10. UNIX接口</h2><ul>
<li><p>shell：使可不用离开gdb下启动unix外壳，即暂时退出gdb调试回到用户控制终端</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell</span><br></pre></td></tr></table></figure>
</li>
<li><p>exit（快捷键ctrl+d）：退出unix外壳，返回到 gdb</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-工作目录"><a href="#11-工作目录" class="headerlink" title="11. 工作目录"></a>11. 工作目录</h2><ul>
<li><p>cd：改变工作目录</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cd [path]</span><br></pre></td></tr></table></figure>
</li>
<li><p>pwd：显示工作目录</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) pwd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-机器语言工具"><a href="#12-机器语言工具" class="headerlink" title="12. 机器语言工具"></a>12. 机器语言工具</h2><p>有一组专用的gdb变量可以用来检查和修改计算机的通用寄存器，gdb提供了目前每一台计算机中实际使用的4个寄存器的标准名字：</p>
<ul>
<li>$pc ： 程序计数器</li>
<li>$fp ： 帧指针（当前堆栈帧）</li>
<li>$sp ： 栈指针</li>
<li>$ps ： 处理器状态</li>
</ul>
<h2 id="13-命令的历史"><a href="#13-命令的历史" class="headerlink" title="13. 命令的历史"></a>13. 命令的历史</h2><p>为了允许使用历史命令，可使用 set history expansion on 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set history expansion on</span><br></pre></td></tr></table></figure>
<h2 id="14-查看机器码"><a href="#14-查看机器码" class="headerlink" title="14. 查看机器码"></a>14. 查看机器码</h2><ul>
<li><p>disassemble： 查看执行时源代码的机器码</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble b.func</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt;</span><br><span class="line">0x00005555555549b8 &lt;+0&gt;:    push   %rbp</span><br><span class="line">0x00005555555549b9 &lt;+1&gt;:    mov    %rsp,%rbp</span><br><span class="line">0x00005555555549bc &lt;+4&gt;:    sub    $0x20,%rsp</span><br><span class="line">0x00005555555549c0 &lt;+8&gt;:    mov    %rdi,-0x18(%rbp)</span><br><span class="line">0x00005555555549c4 &lt;+12&gt;:   mov    %esi,-0x1c(%rbp)</span><br><span class="line">0x00005555555549c7 &lt;+15&gt;:   movl   $0x0,-0x4(%rbp)</span><br><span class="line">0x00005555555549ce &lt;+22&gt;:   mov    -0x4(%rbp),%eax</span><br><span class="line">0x00005555555549d1 &lt;+25&gt;:   cmp    -0x1c(%rbp),%eax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="四、多进程调试"><a href="#四、多进程调试" class="headerlink" title="四、多进程调试"></a>四、多进程调试</h1><p>在进行多进程调试的时候，我们在 fork() 函数后的父进程与子进程代码段内分别设有断点并运行调试的时候会发现，父进程能够在断点处正常停止，而子进程会忽略断点继续运行，因此需要一定的手段调试多进程程序。</p>
<h2 id="1-使用调试器选项-follow-fork-mode-和-detach-on-fork"><a href="#1-使用调试器选项-follow-fork-mode-和-detach-on-fork" class="headerlink" title="1. 使用调试器选项 follow-fork-mode 和 detach-on-fork"></a>1. 使用调试器选项 follow-fork-mode 和 detach-on-fork</h2><ul>
<li><p>follow-fork-mode 选项</p>
<p>  用于选择调试指定进程，但只能同时调试其中一个进程，另一个进程会忽略断点继续运行。命令格式为：  </p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode mode</span><br></pre></td></tr></table></figure>
<p>  其中 mode 的可选值是：</p>
<blockquote>
<p>parent： 仅调试父进程，默认值<br>child： 仅调试子进程</p>
</blockquote>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set follow-fork-mode child</span><br></pre></td></tr></table></figure>
<p>  此时 gdb 将调试子进程，并忽略父进程的断点。若想同时调试父/子进程，则需要使用 detach-on-fork 选项。</p>
</li>
<li><p>detach-on-fork 选项</p>
<p>  指示 GDB 在 fork 之后是否断开（detach）某个进程的调试，或者都交由 GDB 控制。命令格式为：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set detach-on-fork mode</span><br></pre></td></tr></table></figure>
<p>  其中 mode 的可选值是：</p>
<blockquote>
<p>off： 断开（可同时调试）<br>on： 断开（不能同时调试），默认值  </p>
</blockquote>
<p>  当 mode 为 off 时，其中某个进程将会<code>阻塞</code>在 fork 位置，具体如下表所示：</p>
<p>  | follow-fork-mode | detach-on-fork | 说明                                                 |<br>  | :————–: | :————: | :————————————————–: |<br>  | parent           | on             | 只调试父进程（GDB默认）                              |<br>  | child            | on             | 只调试子进程                                         |<br>  | parent           | off            | 同时调试两个进程，gdb 调试父进程，子进程 block 在 fork 位置 |<br>  | child            | off            | 同时调试两个进程，gdb 调试子进程，父进程 block 在 fork 位置 |</p>
<p>  即，若要同时调试两个进程，可以进行如下设置：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set follow-fork-mode child    # 调试子进程</span><br><span class="line">(gdb) set detach-on-fork off        # 关闭进程分离，同时调试父进程（父进程默认阻塞在 fork 函数）</span><br><span class="line">(gdb) b 18                          # 在子进程代码区设断点</span><br><span class="line">(gdb) r</span><br></pre></td></tr></table></figure>
<p>  <code>注</code>：该方法并不适合所有 Linux， 因此需要采用其他方法。</p>
</li>
</ul>
<h2 id="2-使用-attach-命令"><a href="#2-使用-attach-命令" class="headerlink" title="2. 使用 attach 命令"></a>2. 使用 attach 命令</h2><p>众所周知，GDB 有附着（attach）到正在运行的进程的功能，即 attach \&lt; pid > 命令。因此我们可以利用该命令 attach 到子进程然后进行调试。</p>
<p>首先我们需要查看运行程序的进程ID，使用如下命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep test</span><br></pre></td></tr></table></figure>
<p>查找到你运行的程序的PID，并在 gdb 下使用 attach 命令可以附着在该进程下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach PID  # 其中，PID是要调试的进程ID</span><br></pre></td></tr></table></figure>
<p>被成功附着的进程将直接暂停执行，此时你可以正常来调试。</p>
<p>脱离进程使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) detach</span><br></pre></td></tr></table></figure>
<p><code>注</code>：部分 Linux 需要在<code>超级用户</code>下运行 gdb 才能 attach 成功。</p>
<p>一个新的问题是，<strong><code>子进程一直在运行，attach上去后都不知道运行到哪里了。有没有办法解决呢？</code></strong></p>
<p>至于这段代码所采用的条件，看你的偏好了。比如我们可以在需要调试的进程（可以同时调试多个进程）的代码处添加个<code>无限循环</code>并配合 sleep 函数，然后配合使用 jump、next 命令或者其他修改变量的命令如 set 改变循环条件退出循环。以 jump 为例，其形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent ID： "</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">... <span class="comment">// 其他代码，使用 jump 跳转至此</span></span><br></pre></td></tr></table></figure>
<h1 id="五、多线程调试"><a href="#五、多线程调试" class="headerlink" title="五、多线程调试"></a>五、多线程调试</h1><p>gdb调试一般有两种模式：all-stop模式和no-stop模式（gdb7.0之前不支持no-stop模式）。</p>
<ul>
<li><p>all-stop 模式</p>
<p>  在这种模式下，<code>当你的程序在gdb由于任何原因而停止，所有的线程都会停止</code>，而不仅仅是当前的线程。一般来说，gdb不能单步所有的线程。因为线程调度是gdb无法控制的。<code>无论什么时候当gdb停止你的程序，它都会自动切换到触发断点的那个线程</code>。</p>
</li>
<li><p>no-stop模式（网络编程常用）</p>
<p>  当程序在gdb中停止，只有当前的线程会被停止，而其他线程将会继续运行。这时候step，next这些命令就只对当前线程起作用。</p>
</li>
</ul>
<p>如果要打开 no-stop 模式，可以进行如下设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>Enable the async interface</span><br><span class="line">(gdb) set target-async 1</span><br><span class="line"><span class="meta">#</span>If using the CLI, pagination breaks non-stop</span><br><span class="line">(gdb) set pagination off</span><br><span class="line"><span class="meta">#</span>Finall, turn it on</span><br><span class="line">(gdb) set non-stop on</span><br></pre></td></tr></table></figure>
<p>gdb 支持的命里有两种类型：前台的（同步的）和后台（异步 ）的。区别很简单，同步的在输出提示符之前会等待程序 report 一些线程已经终止的信息，异步则是直接返回。所以我们需要 set target-async 1。set pagination off 可以不让线程结束的时候出现 Type &lt; return &gt; to continue 的提示信息 。最后一步是打开。</p>
<p>下面是常用命令：</p>
<ul>
<li><p>info threads</p>
<p>  显示所有线程。</p>
</li>
<li><p>thread id</p>
<p>  切换到指定线程。</p>
</li>
<li><p>break FileName.cpp:LinuNum thread all</p>
<p>  所有线程都在文件 FileName.cpp 的第 LineNum 行有断点。</p>
</li>
<li><p>thread apply ID1 ID2 IDN command</p>
<p>  让线程编号是 ID1，ID2… 等等的线程都执行 command 命令。</p>
</li>
<li><p>thread apply all command</p>
<p>  所有线程都执行 command 命令。</p>
</li>
<li><p>set scheduler-locking off|on|step：</p>
<p>  在调式某一个线程时，其他线程是否执行。在使用 step 或 continue 命令调试当前被调试线程的时候，其他线程也是同时执行的，如果我们只想要被调试的线程执行，而其他线程停止等待，那就要锁定要调试的线程，只让他运行。其中：</p>
<blockquote>
<p>off：不锁定任何线程，默认值。<br>on：锁定其他线程，只有当前线程执行。<br>step：在 step （单步）时，只有被调试线程运行。</p>
</blockquote>
</li>
<li><p>set non-stop on/off</p>
<p>  当调式一个线程时，其他线程是否运行。</p>
</li>
<li><p>set pagination on/off</p>
<p>  在使用 backtrace 时，在分页时是否停止。</p>
</li>
<li><p>set target-async on/off</p>
<p>  是否开启同步和异步。其中：</p>
<blockquote>
<p>on：同步，gdb 在输出提示符之前等待程序报告一些线程已经终止的信息。<br>off： 异步，线程结束后则是直接返回。</p>
</blockquote>
</li>
<li><p>show scheduler-locking</p>
<p>  查看当前锁定线程的模式。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/water_cow/article/details/7214054" title="GDB基本命令(整合)" target="_blank" rel="noopener">GDB 基本命令(整合)</a></li>
<li><a href="https://blog.csdn.net/freeelinux/article/details/53700266" title="GDB常用调试命令以及多进程多线程调试" target="_blank" rel="noopener">GDB 常用调试命令以及多进程多线程调试</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/" title="使用 GDB 调试多进程程序" target="_blank" rel="noopener">使用 GDB 调试多进程程序</a></li>
<li><a href="https://blog.csdn.net/snow_5288/article/details/72982594" title="gdb调试多进程与多线程" target="_blank" rel="noopener">gdb调试多进程与多线程</a></li>
</ul>

      
    </div>

    

    
    
    

<div>
  
    <div>

    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文到此结束 <i class="fa fa-smile-o"></i> 感谢您的阅读-------------</div>

</div>
  
</div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/reward/wechatpay.png" alt="leitmily 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/reward/alipay.jpg" alt="leitmily 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>leitmily</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://letmily.gitee.io/2018/07/20/gdb/" title="GDB 基本用法，以及多进程、多线程的调试">https://letmily.gitee.io/2018/07/20/gdb/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/GDB/" rel="tag"># GDB</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/10/test/" rel="next" title="TEST">
                <i class="fa fa-chevron-left"></i> TEST
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/27/inc/" rel="prev" title="linux下C/C++编程导入第三方库文件的几种方法">
                linux下C/C++编程导入第三方库文件的几种方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/avatar.jpg"
                alt="leitmily" />
            
              <p class="site-author-name" itemprop="name">leitmily</p>
              <p class="site-description motion-element" itemprop="description">go go fighting!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/leitmily" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:494187160@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/kiss0tql" target="_blank" title="CSDN"><i class="fa fa-fw fa-repeat"></i>CSDN</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、GDB-调试基本知识"><span class="nav-number">1.</span> <span class="nav-text">一、GDB 调试基本知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、GDB-基本命令清单查询"><span class="nav-number">2.</span> <span class="nav-text">二、GDB 基本命令清单查询</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、GDB-基本命令用法"><span class="nav-number">3.</span> <span class="nav-text">三、GDB 基本命令用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-运行和退出"><span class="nav-number">3.1.</span> <span class="nav-text">1. 运行和退出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-查看信息"><span class="nav-number">3.2.</span> <span class="nav-text">2. 查看信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-暂停执行"><span class="nav-number">3.3.</span> <span class="nav-text">3. 暂停执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置断点"><span class="nav-number">3.3.1.</span> <span class="nav-text">设置断点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断点的管理"><span class="nav-number">3.3.2.</span> <span class="nav-text">断点的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为断点设置命令列表"><span class="nav-number">3.3.3.</span> <span class="nav-text">为断点设置命令列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监视点"><span class="nav-number">3.3.4.</span> <span class="nav-text">监视点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#捕捉点"><span class="nav-number">3.3.5.</span> <span class="nav-text">捕捉点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-恢复执行"><span class="nav-number">3.4.</span> <span class="nav-text">4. 恢复执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-变量赋值"><span class="nav-number">3.5.</span> <span class="nav-text">5. 变量赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-函数调用"><span class="nav-number">3.6.</span> <span class="nav-text">6. 函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-栈信息"><span class="nav-number">3.7.</span> <span class="nav-text">7. 栈信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-信号"><span class="nav-number">3.8.</span> <span class="nav-text">8. 信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-字段搜索"><span class="nav-number">3.9.</span> <span class="nav-text">9. 字段搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-UNIX接口"><span class="nav-number">3.10.</span> <span class="nav-text">10. UNIX接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-工作目录"><span class="nav-number">3.11.</span> <span class="nav-text">11. 工作目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-机器语言工具"><span class="nav-number">3.12.</span> <span class="nav-text">12. 机器语言工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-命令的历史"><span class="nav-number">3.13.</span> <span class="nav-text">13. 命令的历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-查看机器码"><span class="nav-number">3.14.</span> <span class="nav-text">14. 查看机器码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、多进程调试"><span class="nav-number">4.</span> <span class="nav-text">四、多进程调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-使用调试器选项-follow-fork-mode-和-detach-on-fork"><span class="nav-number">4.1.</span> <span class="nav-text">1. 使用调试器选项 follow-fork-mode 和 detach-on-fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-使用-attach-命令"><span class="nav-number">4.2.</span> <span class="nav-text">2. 使用 attach 命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、多线程调试"><span class="nav-number">5.</span> <span class="nav-text">五、多线程调试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leitmily</span>

  

  
</div>











        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  








  







  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.3.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.3.0"></script>


  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>